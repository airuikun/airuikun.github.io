<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>nodeJS 菜鸟入门 | Iray&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="从一个简单的 HTTP 服务开始旅程……创建一个 server.js 文件，写入：
//最简单的 http 服务例子
var http = require(&quot;http&quot;);
http.createServer(function(request, response) {
    response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/html&quot;});
    r">
<meta property="og:type" content="article">
<meta property="og:title" content="nodeJS 菜鸟入门">
<meta property="og:url" content="http://airuikun.github.io/2015/12/10/2015-12-10-nodeJS 笔记/index.html">
<meta property="og:site_name" content="Iray's blog">
<meta property="og:description" content="从一个简单的 HTTP 服务开始旅程……创建一个 server.js 文件，写入：
//最简单的 http 服务例子
var http = require(&quot;http&quot;);
http.createServer(function(request, response) {
    response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/html&quot;});
    r">
<meta property="og:image" content="http://images.cnitblog.com/blog/531703/201502/111631185424695.gif">
<meta property="og:updated_time" content="2016-04-25T09:03:32.473Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="nodeJS 菜鸟入门">
<meta name="twitter:description" content="从一个简单的 HTTP 服务开始旅程……创建一个 server.js 文件，写入：
//最简单的 http 服务例子
var http = require(&quot;http&quot;);
http.createServer(function(request, response) {
    response.writeHead(200, {&quot;Content-Type&quot;: &quot;text/html&quot;});
    r">
  
    <link rel="alternative" href="/atom.xml" title="Iray&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Iray&#39;s blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">艾瑞坤的博客 | WEB前端,一路前行</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://airuikun.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-2015-12-10-nodeJS 笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/12/10/2015-12-10-nodeJS 笔记/" class="article-date">
  <time datetime="2015-12-10T08:15:06.000Z" itemprop="datePublished">2015-12-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      nodeJS 菜鸟入门
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="从一个简单的_HTTP_服务开始旅程……">从一个简单的 HTTP 服务开始旅程……</h4><p>创建一个 <code>server.js</code> 文件，写入：</p>
<pre><code><span class="comment">//最简单的 http 服务例子</span>
<span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);
http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>{
    response.writeHead(<span class="number">200</span>, {<span class="string">"Content-Type"</span>: <span class="string">"text/html"</span>});
    response.write(<span class="string">"&lt;h1&gt;Hi NodeJs&lt;/h1&gt;"</span>);
    response.end();
}).listen(<span class="number">8080</span>);
<span class="built_in">console</span>.log(<span class="string">"成功的提示：httpd start @8080"</span>);
</code></pre><p>打开 <code><a href="http://localhost:8080/" target="_blank" rel="external">http://localhost:8080/</a></code> 你会看到惊喜~</p>
<blockquote>
<p>tips</p>
<p>执行： <code>node server.js</code>启动服务。<br>按 <kbd>Ctrl + c</kbd> 结束 刚刚创建的服务。</p>
</blockquote>
<a id="more"></a>
<h4 id="分析该HTTP服务">分析该HTTP服务</h4><ol>
<li>http服务器： Node.JS 自带的， <strong>http</strong> 模块</li>
<li>createServer： 调用该返回的对象中的 listen 方法，对服务端口进行监听</li>
<li>复习下 <em>匿名函数</em> </li>
</ol>
<h6 id="匿名函数的变化">匿名函数的变化</h6><pre><code><span class="comment">//自带的http 模块</span>
<span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);

<span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request, response</span>) </span>{
  <span class="comment">//console.log("请求来了，事件响应");</span>
  response.writeHead(<span class="number">200</span>, {<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>});
  response.write(<span class="string">"&lt;h1&gt;Hi NodeJs&lt;/h1&gt;"</span>);
  response.end();
}

http.createServer(onRequest).listen(<span class="number">8080</span>);
<span class="built_in">console</span>.log(<span class="string">"成功的提示：httpd start @8080"</span>);
</code></pre><h6 id="扩展_事件驱动">扩展 <strong>事件驱动</strong></h6><p>Felix Geisendörfer 的 <a href="http://debuggable.com/posts/understanding-node-js:4bd98440-45e4-4a9a-8ef7-0f7ecbdd56cb" title="理解NodeJS" target="_blank" rel="external"> Understanding node.js (理解NodeJS) </a></p>
<ul>
<li>php： 任何时候当有请求进入的时候，网页服务器（通常是Apache）就为这一请求新建一个进程，并且开始从头到尾执行相应的PHP脚本；</li>
<li>Node.js： 事件驱动设计</li>
<li>证明 NodeJS 的事件驱动设计： 去掉以上代码 这个注释<br><code>//console.log(“请求来了，事件响应”);</code> 启动 server.js</li>
<li>结果： 启动服务时，输出 <em>成功……</em> 执行网页请求时，输出 <em>请求……</em> </li>
<li>一次http请求输出俩次事件是因为：大部分服务器都会在你访问 <a href="http://localhost:8080" target="_blank" rel="external">http://localhost:8080</a> /时尝试读取 <a href="http://localhost:8080/favicon.ico" target="_blank" rel="external">http://localhost:8080/favicon.ico</a> </li>
</ul>
<h4 id="模块化">模块化</h4><h6 id="把_server-js_变成一个模块:">把 server.js 变成一个模块:</h6><pre><code><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);

<span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>{
  <span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request, response</span>) </span>{
    <span class="comment">//console.log("请求来了，事件响应");</span>
    response.writeHead(<span class="number">200</span>, {<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>});
    response.write(<span class="string">"Hi NodeJS"</span>);
    response.end();
  }

  http.createServer(onRequest).listen(<span class="number">8080</span>);
  <span class="built_in">console</span>.log(<span class="string">"成功的提示：httpd start @8080"</span>);
}
<span class="comment">//nodejs中exports对象，理解 **module.exports** 和 **exports**</span>
exports.start = start;
</code></pre><blockquote>
<h5 id="理解_module-exports_和_exports_:">理解 module.exports 和 exports :</h5><p><strong>exports</strong> 获取的所有的属性和方法，都会传递给 <strong>Module.exports</strong><br>但是 <strong>Module.exports</strong> 本身不具备任何属性和方法。如果， <strong>Module.exports</strong> 已经具备某些属性或方法，那么 <strong>exports</strong> 传递的属性或者方法会被忽略（失败）。</p>
<h5 id="代码举例">代码举例</h5></blockquote>
<pre><code><span class="comment">// a.js</span>
exports.words = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">'Hi'</span>);
};

<span class="comment">// b.js</span>
<span class="keyword">var</span> say = <span class="built_in">require</span>(<span class="string">'./a.js'</span>);
say.words(); <span class="comment">// 'Hi'</span>

<span class="comment">//----分割线----</span>

<span class="comment">// aa.js</span>
<span class="built_in">module</span>.exports = <span class="string">'Wellcome'</span>;
exports.words = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">'Hi'</span>);
};

<span class="comment">// bb.js</span>
<span class="keyword">var</span> say = <span class="built_in">require</span>(<span class="string">'./aa.js'</span>);
say.words(); <span class="comment">// TypeError: Object Wellcome has no method 'words'</span>
</code></pre><p>&gt;</p>
<h6 id="调用">调用</h6><p>创建 index.js 写入：</p>
<pre><code>var <span class="keyword">server</span> = require(<span class="string">"./server"</span>);

<span class="keyword">server</span>.start();
</code></pre><p>启动： <code>node index.js</code> 看看吧！</p>
<h6 id="牛刀小试_路由选择模块">牛刀小试 路由选择模块</h6><p>作为 ThinkPHP 的玩家，肯定能想到 TP 的路由： 通过实例化对象来实现路由选择；<br>现在来看看 node 是怎么来实现的：</p>
<p>1 、提取出请求的URL以及GET/POST参数，这里需要额外的NodeJS模块：<em>URL</em> 、 <em>querystring</em></p>
<p><code>仔细看下图：</code></p>
<pre><code>                       url.parse(string).query
                                           |<span class="string">
           url.parse(string).pathname      </span>|
                       |<span class="string">                   </span>|
                       |<span class="string">                   </span>|
                     -----   ------------------
http://localhost:8080/start?foo=bar&amp;hello=world
                                ---       -----
                                 |<span class="string">          </span>|
                                 |<span class="string">          </span>|
              querystring(string)[<span class="string">"foo"</span>]    |<span class="string">
                                            </span>|
                         querystring(string)[<span class="string">"hello"</span>]
</code></pre><p>2 、帮助 <em>onRequest()函数</em> 找出浏览器请求的URL路径 </p>
<p>先新建一个 <strong>router.js</strong> 写入，能够输出当前请求的路径名称</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">route</span>(<span class="params">pathname</span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">"请求路径是："</span> + pathname);
}
exports.route = route;
</code></pre><p>再扩展 <strong>server.js</strong></p>
<pre><code><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>),
    <span class="comment">//URL模块可以读取URL、分析诸如hostname、port之类的信息</span>
    url  = <span class="built_in">require</span>(<span class="string">"url"</span>);

<span class="comment">//传入 route (回调函数)</span>
<span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">route</span>) </span>{
    <span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request, response</span>) </span>{
        <span class="keyword">var</span> pathname = url.parse(request.url).pathname;
        <span class="comment">//console.log("请求 "+pathname+" ，事件");</span>

        route(pathname);

        response.writeHead(<span class="number">200</span>, {<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>});
        response.write(<span class="string">"Hi NodeJS"</span>);
        response.end();
    }

    http.createServer(onRequest).listen(<span class="number">8080</span>);
    <span class="built_in">console</span>.log(<span class="string">"成功的提示：httpd start @8080"</span>);
}

exports.start = start;
</code></pre><p>最后扩展 <strong>index.js</strong></p>
<pre><code><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">"./server"</span>);
<span class="keyword">var</span> router = <span class="built_in">require</span>(<span class="string">"./router"</span>);

server.start(router.route);
</code></pre><p>启动，输入 <code><a href="http://localhost:8080/a" target="_blank" rel="external">http://localhost:8080/a</a></code> 结果</p>
<pre><code>$ node index<span class="class">.js</span>
成功的提示：httpd start @<span class="number">8080</span>
请求路径是：/<span class="tag">a</span>
请求路径是：/favicon.ico
</code></pre><blockquote>
<p>扩展：</p>
<p>Martin Fowlers <a href="http://martinfowler.com/articles/injection.html" title="关于依赖注入的大作" target="_blank" rel="external">关于依赖注入的大作</a></p>
</blockquote>
<h4 id="函数编程">函数编程</h4><p>注重：数学本质、抽象本质。<br>重要的概念：循环可以没有（描述如何解决问题），递归（描述这个问题的定义）是不可或缺；<br>面向对象编程是 传递对象；而在函数式编程中，传递的是函数(更专业的叫：叫做高阶函数)<br>高阶函数：a、接受一个或多个函数输入；b、输出一个函数</p>
<p>其他， 行为驱动执行 (BDD) 和 测试驱动开发(TDD)</p>
<blockquote>
<p>函数编程扩展阅读：</p>
<p><a href="http://www.cnblogs.com/kym/archive/2011/03/07/1976519.html" title="函数式编程扫盲篇" target="_blank" rel="external">函数式编程扫盲篇</a><br><a href="http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html" title="名词王国中的死刑" target="_blank" rel="external">Steve Yegge 名词王国中的死刑</a></p>
</blockquote>
<h4 id="路由处理函数">路由处理函数</h4><p>示例，创建一个 <code>requestHandlers.js</code> 模块</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">"处理请求 'start' 开启."</span>);
}

<span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params"></span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">"处理请求 'upload' 开启."</span>);
}

exports.start = start;
exports.upload = upload;
</code></pre><h6 id="对象传递">对象传递</h6><p>将一系列请求处理程序通过一个对象来传递，并且需要使用松耦合的方式将这个对象注入到 <em>route()</em> 函数中</p>
<p>1、先将这个对象引入到主文件 <strong>index.js</strong> 中</p>
<pre><code><span class="built_in">var</span> server = <span class="keyword">require</span>(<span class="string">"./server"</span>),
    router = <span class="keyword">require</span>(<span class="string">"./router"</span>),
    requestHandlers = <span class="keyword">require</span>(<span class="string">"./requestHandlers"</span>);

<span class="built_in">var</span> <span class="keyword">handle</span> = {};
    <span class="keyword">handle</span><span class="preprocessor">[</span><span class="string">"/"</span><span class="preprocessor">]</span><span class="markup"> = requestHandlers.start;
    handle</span><span class="preprocessor">[</span><span class="string">"/start"</span><span class="preprocessor">]</span><span class="markup"> = requestHandlers.start;
    handle</span><span class="preprocessor">[</span><span class="string">"/upload"</span><span class="preprocessor">]</span><span class="markup"> = requestHandlers.upload;

server.start(router.route, handle);</span>
</code></pre><p>2、把额外的传递参数 <em>handle</em> 给服务器 <strong>server.js</strong></p>
<pre><code><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>),
    url  = <span class="built_in">require</span>(<span class="string">"url"</span>);

<span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">route, handle</span>) </span>{
    <span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request, response</span>) </span>{
        <span class="keyword">var</span> pathname = url.parse(request.url).pathname;
        <span class="built_in">console</span>.log(<span class="string">"请求 "</span>+pathname+<span class="string">" 响应"</span>);

        route(handle, pathname);

        response.writeHead(<span class="number">200</span>, {<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>});
        response.write(<span class="string">"Hi NodeJS"</span>);
        response.end();
    }

    http.createServer(onRequest).listen(<span class="number">8080</span>);
    <span class="built_in">console</span>.log(<span class="string">"成功的提示：httpd start @8080"</span>);
}

exports.start = start;
</code></pre><p>3、修改 <strong>router.js</strong></p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">route</span>(<span class="params">handle, pathname</span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">"route 请求路径："</span> + pathname);
    <span class="keyword">if</span> (<span class="keyword">typeof</span> handle[pathname] === <span class="string">'function'</span>) {
        handle[pathname]();
    } <span class="keyword">else</span> {
        <span class="built_in">console</span>.log(<span class="string">"找不到路径 "</span> + pathname);
    }
}

exports.route = route;
</code></pre><p>4、运行结果： <code><a href="http://localhost:8080/start" target="_blank" rel="external">http://localhost:8080/start</a></code></p>
<pre><code>$ node index<span class="class">.js</span>
成功的提示：httpd start @<span class="number">8080</span>
请求 /start 响应
route 请求路径：/start
处理请求 <span class="string">'start'</span> 开启.
请求 /favicon<span class="class">.ico</span> 响应
route 请求路径：/favicon<span class="class">.ico</span>
找不到路径 /favicon.ico
</code></pre><h4 id="和浏览器的互动">和浏览器的互动</h4><p>浏览器需要对请求作出响应。</p>
<h6 id="不好的实现方式">不好的实现方式</h6><p>1、将 <strong>requestHandler.js</strong> 修改为</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">"处理请求 'start' 开启."</span>);
    <span class="keyword">return</span> <span class="string">"Hello Start"</span>;
}

<span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params"></span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">"处理请求 'upload' 开启."</span>);
    <span class="keyword">return</span> <span class="string">"Hello Upload"</span>;
}

exports.start = start;
exports.upload = upload;
</code></pre><p>2、将 <strong>router.js</strong> 修改为</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">route</span>(<span class="params">handle, pathname</span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">"route 请求路径："</span> + pathname);
    <span class="keyword">if</span> (<span class="keyword">typeof</span> handle[pathname] === <span class="string">'function'</span>) {
        <span class="keyword">return</span> handle[pathname]();
    } <span class="keyword">else</span> {
        <span class="built_in">console</span>.log(<span class="string">"找不到路径 "</span> + pathname);
        <span class="keyword">return</span> <span class="string">'404 Not Found'</span>
    }
}

exports.route = route;
</code></pre><p>3、需要对 <strong>server.js</strong> 进行重构，以使得它能够将请求处理程序通过请求路由返回的内容 响应 给浏览器</p>
<pre><code><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>),
    url  = <span class="built_in">require</span>(<span class="string">"url"</span>);

<span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">route, handle</span>) </span>{
    <span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request, response</span>) </span>{
        <span class="keyword">var</span> pathname = url.parse(request.url).pathname;
        <span class="built_in">console</span>.log(<span class="string">"请求 "</span>+pathname+<span class="string">" 响应"</span>);
        response.writeHead(<span class="number">200</span>, {<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>});

        <span class="keyword">var</span> content = route(handle, pathname);

        response.write(content);
        response.end();
    }
    http.createServer(onRequest).listen(<span class="number">8080</span>);
    <span class="built_in">console</span>.log(<span class="string">"成功的提示：httpd start @8080"</span>);
}

exports.start = start;
</code></pre><p>4、运行结果：当输入 /start 是浏览器显示 hello start ……</p>
<blockquote>
<p>缺点:</p>
<p>当未来有请求处理程序需要进行 <strong>非阻塞</strong> 的操作的时候，我们的应用就“挂”了。</p>
</blockquote>
<h5 id="阻塞与非阻塞">阻塞与非阻塞</h5><p>在请求处理程序中加入阻塞操作的用例 <strong>requestHandlers.js</strong>：</p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">"处理请求 'start' 开启."</span>);

    <span class="function"><span class="keyword">function</span> <span class="title">sleep</span> (<span class="params">milliSeconds</span>) </span>{
        <span class="keyword">var</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();
        <span class="keyword">while</span> (<span class="keyword">new</span> <span class="built_in">Date</span>().getTime() &lt; startTime + milliSeconds);
    }

    sleep(<span class="number">10000</span>);
    <span class="keyword">return</span> <span class="string">"Hello Start"</span>;
}

<span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params"></span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">"处理请求 'upload' 开启."</span>);
    <span class="keyword">return</span> <span class="string">"Hello Upload"</span>;
}

exports.start = start;
exports.upload = upload;
</code></pre><p>这样，当 <em>start()</em> 被调用的时候，Node.js会先等待10秒，之后才会返回 “Hello Start” 。当调用 <em>upload()</em> 的时候，会和此前一样立即返回。</p>
<p>但是，当你打开两个浏览器窗口或者标签页，<br>第一个输入 <a href="http://localhost:8080/start" target="_blank" rel="external">http://localhost:8080/start</a> 但是先不“回车”；<br>第二个输入 <a href="http://localhost:8080/upload" target="_blank" rel="external">http://localhost:8080/upload</a> 同样先不“回车”<br>接下来在第一个窗口中 /start 按下回车，快速的切到第二个窗口再按下回车……<br>会看到： /start 花了10s加载url， upload 居然也是！<br>原因就是 start() 包含了阻塞操作。形象的说就是“它阻塞了所有其他的处理工作”。</p>
<blockquote>
<p>tips</p>
<p>1、Node.js是单线程的。它通过事件轮询（event loop）来实现并行操作<br>2、避免阻塞操作，多使用非阻塞操作————回调（ <strong>callbackFunction()</strong> ）</p>
</blockquote>
<h5 id="一种错误的使用非阻塞操作的方式">一种错误的使用非阻塞操作的方式</h5><p>修改 <strong>requestHandlers.js</strong> 中的 start 请求处理程序</p>
<pre><code><span class="comment">//child_process 可以创建多进程，利用多核计算资源。</span>
<span class="keyword">var</span> exec = <span class="built_in">require</span>(<span class="string">"child_process"</span>).exec;

<span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">"处理请求 'start' 开启."</span>);
    <span class="keyword">var</span> content = <span class="string">"empty"</span>;

    exec(<span class="string">"ls -lah"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, stdout, stderr</span>) </span>{
        content = stdout;
      });

    <span class="keyword">return</span> content;
}

<span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params"></span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">"处理请求 'upload' 开启."</span>);
    <span class="keyword">return</span> <span class="string">"Hello Upload"</span>;
}

exports.start = start;
exports.upload = upload;
</code></pre><p>上述代码创建了一个新的变量content（初始值为“empty”），执行 “ls -lah” 命令，将结果赋值给 content ，最后将content返回。<br>接下来 重启服务 访问 <a href="http://localhost:8080/start" target="_blank" rel="external">http://localhost:8080/start</a> 结果是 empty ，<br>这时，exec() 在非阻塞这块发挥了作用。它可以执行非常耗时的 shell 操作而无需网页应用等待该操作。</p>
<p>但是代码是同步执行的，这就意味着在调用 exec() 之后，Node.js会立即执行 <code>return content;</code> 在这个时候，content仍然是 “empty” ，因为传递给 exec() 的回调函数还未执行到————因为 exec() 的操作是异步的……</p>
<blockquote>
<p>tips:<br>child_process 模块提供四个创建子进程的函数: spawn，exec，execFile和fork<br>其中 spawn 是最原始的创建子进程的函数，其他三个都是对 spawn 不同程度的封装。 spawn 只能运行指定的程序，参数需要在列表中给出，相当于 execvp 系统函数，而 exec 可以直接运行复杂的命令<br>例子：运行ls -lh /usr </p>
</blockquote>
<pre><code><span class="comment">//使用 spawn</span>
<span class="function"><span class="title">spawn</span><span class="params">(<span class="string">'ls'</span>, [<span class="string">'-lh'</span>, <span class="string">'/usr'</span>])</span></span>
<span class="comment">//使用 exec</span>
<span class="function"><span class="title">exec</span><span class="params">(<span class="string">'ls -lh /usr'</span>)</span></span>
</code></pre><blockquote>
<p>exec 是启动了一个系统 shell 命令来解析参数，可以执行复杂的命令，包括管道和重定向。<br>exec 还可以直接接受一个回调函数作为参数，回调函数有三个参数，分别是 err, stdout, stderr</p>
</blockquote>
<h5 id="以非阻塞操作进行请求响应（正确的方式）">以非阻塞操作进行请求响应（正确的方式）</h5><p>实现方案： 函数编程(函数传递)</p>
<p>目前的结果：通过应用各层之间传递值的方式（请求处理程序 -&gt; 请求路由 -&gt; 服务器）将请求处理程序返回的内容（请求处理程序最终要显示给用户的内容）传递给HTTP服务器。</p>
<p>新实现方式：将服务器“传递”给内容的方式。从实践角度来说，就是将response对象（从服务器的回调函数 onRequest() 获取）通过请求路由传递给请求处理程序。 随后，处理程序就可以采用该对象上的函数来对请求作出响应。</p>
<p>1、 <strong>server.js</strong></p>
<pre><code><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>),
    url  = <span class="built_in">require</span>(<span class="string">"url"</span>);

<span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">route, handle</span>) </span>{
    <span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request, response</span>) </span>{
        <span class="keyword">var</span> pathname = url.parse(request.url).pathname;
        <span class="built_in">console</span>.log(<span class="string">"请求 "</span>+pathname+<span class="string">" 响应"</span>);

        route(handle, pathname, response);

    }
    http.createServer(onRequest).listen(<span class="number">8080</span>);
    <span class="built_in">console</span>.log(<span class="string">"成功的提示：httpd start @8080"</span>);
}

exports.start = start;
</code></pre><p>不再从 route() 函数获取返回值，而将 response 对象作为第三个参数传递给 route() 函数，并且，移除 onRequest() 中有关 response 的函数调用，这部分让 route() 函数完成。</p>
<p>2、 <strong>router.js</strong></p>
<pre><code><span class="keyword">function</span> route(handle, pathname, <span class="built_in">response</span>) {
    console.<span class="built_in">log</span>(<span class="string">"route 请求路径："</span> + pathname);
    <span class="keyword">if</span> (typeof handle[pathname] === <span class="comment">'function') {</span>
        handle[pathname](<span class="built_in">response</span>);
    } <span class="keyword">else</span> {
        console.<span class="built_in">log</span>(<span class="string">"找不到路径 "</span> + pathname);
        <span class="built_in">response</span>.writeHead(<span class="number">404</span>, {<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>});
        <span class="built_in">response</span>.write(<span class="string">"404 Not found"</span>);
        <span class="built_in">response</span>.<span class="keyword">end</span>();
    }
}

exports.route = route;
</code></pre><p>相对此前从请求处理程序中获取返回值，这次取而代之的是直接传递 response 对象。</p>
<p>3、 <strong>requestHandler.js</strong></p>
<pre><code>var exec = require(<span class="string">"child_process"</span>).exec;

<span class="keyword">function</span> start(<span class="built_in">response</span>) {
    console.<span class="built_in">log</span>(<span class="string">"处理请求 'start' 开启."</span>);

    exec(<span class="string">"ls -lah"</span>, <span class="keyword">function</span> (<span class="keyword">error</span>, stdout, stderr) {
        <span class="built_in">response</span>.writeHead(<span class="number">200</span>, {<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>});
        <span class="built_in">response</span>.write(stdout);
        <span class="built_in">response</span>.<span class="keyword">end</span>();
    });
}

<span class="keyword">function</span> upload(<span class="built_in">response</span>) {
    console.<span class="built_in">log</span>(<span class="string">"处理请求 'upload' 开启."</span>);
    <span class="built_in">response</span>.writeHead(<span class="number">200</span>, {<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>});
    <span class="built_in">response</span>.write(<span class="string">"Hello Upload"</span>);
    <span class="built_in">response</span>.<span class="keyword">end</span>();
}

exports.start = start;
exports.upload = upload;
</code></pre><p>start 处理程序在 exec() 的匿名回调函数中做请求响应的操作<br>upload 处理程序这次是使用 response 对象。</p>
<p>4、运行结果： 运行很好</p>
<blockquote>
<p>如何 <strong>证明</strong> /start 处理程序中耗时的操作不会阻塞对 /upload 请求作出立即响应？<br>修改 <strong>requestHandlers.js</strong></p>
</blockquote>
<pre><code>var exec = require(<span class="string">"child_process"</span>).exec;

<span class="keyword">function</span> start(<span class="built_in">response</span>) {
    console.<span class="built_in">log</span>(<span class="string">"处理请求 'start' 开启."</span>);

    exec(<span class="string">"find /"</span>,
        { timeout: <span class="number">10000</span>, maxBuffer: <span class="number">2000</span>*<span class="number">1024</span>},
        <span class="keyword">function</span> (<span class="keyword">error</span>, stdout, stderr) {
            <span class="built_in">response</span>.writeHead(<span class="number">200</span>, {<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>});
            <span class="built_in">response</span>.write(stdout);
            <span class="built_in">response</span>.<span class="keyword">end</span>();
        }
    );
}

<span class="keyword">function</span> upload(<span class="built_in">response</span>) {
    console.<span class="built_in">log</span>(<span class="string">"处理请求 'upload' 开启."</span>);
    <span class="built_in">response</span>.writeHead(<span class="number">200</span>, {<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>});
    <span class="built_in">response</span>.write(<span class="string">"Hello Upload"</span>);
    <span class="built_in">response</span>.<span class="keyword">end</span>();
}

exports.start = start;
exports.upload = upload;
</code></pre><p>结果： /upload 时会立即响应，不管 /start 是否还在处理中</p>
<h4 id="场景实战：一个图片上传并在浏览器中显示的功能">场景实战：一个图片上传并在浏览器中显示的功能</h4><p>简单的例子： 用 post 请求提交给服务器 文本区 中的内容； <strong>requestHandlers.js</strong></p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">start</span><span class="params">(response)</span> {</span>
    <span class="transposed_variable">console.</span>log(<span class="string">"处理请求 '</span><span class="transposed_variable">start'</span> 开启.<span class="string">");

    var body = '</span>&lt;html&gt;<span class="string">'+
        '</span>&lt;head&gt;<span class="string">'+
        '</span>&lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; '</span>+
        <span class="string">'charset=UTF-8"</span> /&gt;<span class="string">'+
        '</span>&lt;/head&gt;<span class="string">'+
        '</span>&lt;body&gt;<span class="string">'+
        '</span>&lt;form action=<span class="string">"/upload"</span> method=<span class="string">"post"</span>&gt;<span class="string">'+
        '</span>&lt;textarea name=<span class="string">"text"</span> rows=<span class="string">"20"</span> cols=<span class="string">"60"</span>&gt;&lt;/textarea&gt;<span class="string">'+
        '</span>&lt;input type=<span class="string">"submit"</span> value=<span class="string">" 提 交 "</span> /&gt;<span class="string">'+
        '</span>&lt;/form&gt;<span class="string">'+
        '</span>&lt;/body&gt;<span class="string">'+
        '</span>&lt;/html&gt;<span class="string">';

    response.writeHead(200, {"</span>Content-Type<span class="string">": "</span>text/html<span class="string">"});
    response.write(body);
    response.end();

}

function upload(response) {
    console.log("</span>处理请求 <span class="string">'upload'</span> 开启.<span class="string">");
    response.writeHead(200, {"</span>Content-Type<span class="string">": "</span>text/plain<span class="string">"});
    response.write("</span>Hello Upload<span class="string">");
    response.end();
}

exports.start = start;
exports.upload = upload;</span>
</code></pre><p>因为 POST 请求会比较大（用户可能会填大量内容），为了使整个过程非阻塞， NodeJS 会将数据拆分成很多小数据块，然后通过触发特定的事件，将这些小数据块传递给回调函数。这里的特定的事件有 <strong>data</strong> 事件（表示新的小数据块到达了）以及 <strong>end</strong>事件（表示所有的数据都已经接收完毕）。</p>
<p>通过在 request 对象上注册监听器（listener）来实现这些事件的触发，以及回调；request对象是每次接收到HTTP请求时候，都会把该对象传递给 onRequest 回调函数。</p>
<pre><code>request.addListener(<span class="string">"data"</span>, <span class="function"><span class="keyword">function</span><span class="params">(chunk)</span> </span>{
  <span class="comment">// called when a new chunk of data was received</span>
});

request.addListener(<span class="string">"end"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>{
  <span class="comment">// called when all chunks of data have been received</span>
});
</code></pre><p>这部分的逻辑应该写在哪里？<br>因为获取所有来自请求的数据，然后将这些数据给应用层处理，应该是HTTP服务器要做的事情，所以可以在服务器中处理 POST 数据，然后将最终的数据传递给请求路由和请求处理器，让他们来进行进一步的处理。</p>
<p>1、 <strong>server.js</strong></p>
<pre><code><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>),
    url  = <span class="built_in">require</span>(<span class="string">"url"</span>);

<span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">route, handle</span>) </span>{
    <span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request, response</span>) </span>{
        <span class="keyword">var</span> postData = <span class="string">''</span>,
            pathname = url.parse(request.url).pathname;
        <span class="built_in">console</span>.log(<span class="string">"请求 "</span>+pathname+<span class="string">" 响应"</span>);

        request.setEncoding(<span class="string">'UTF-8'</span>);

        request.addListener(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">postDataChunk</span>)</span>{
            postData += postDataChunk;
            <span class="built_in">console</span>.log(<span class="string">"收到数据块 ‘"</span> + postDataChunk + <span class="string">"’."</span>)
        })

        request.addListener(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
            route(handle, pathname, response, postData);
        });

    }

    http.createServer(onRequest).listen(<span class="number">8080</span>);
    <span class="built_in">console</span>.log(<span class="string">"成功的提示：httpd start @8080"</span>);
}

exports.start = start;
</code></pre><p>以上代码做了三件事：</p>
<ul>
<li>设置接收数据的编码 utf-8</li>
<li>注册 data 事件，收集每次接收到的新数据块并赋值给 postData</li>
<li>当所有数据接收完成在 end 事件中调用路由，传递给请求程序</li>
</ul>
<p>2、接下来需要在 /upload 页面展示用户输入的内容，将 postData 传递给请求处理程序 <strong>router.js</strong></p>
<pre><code><span class="keyword">function</span> route(handle, pathname, <span class="built_in">response</span>, postData) {
    console.<span class="built_in">log</span>(<span class="string">"route 请求路径："</span> + pathname);
    <span class="keyword">if</span> (typeof handle[pathname] === <span class="comment">'function') {</span>
        handle[pathname](<span class="built_in">response</span>, postData);
    } <span class="keyword">else</span> {
        console.<span class="built_in">log</span>(<span class="string">"找不到路径 "</span> + pathname);
        <span class="built_in">response</span>.writeHead(<span class="number">404</span>, {<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>});
        <span class="built_in">response</span>.write(<span class="string">"404 Not found"</span>);
        <span class="built_in">response</span>.<span class="keyword">end</span>();
    }
}

exports.route = route;
</code></pre><p>3、 <strong>requestHandlers.js</strong></p>
<pre><code><span class="function"><span class="keyword">function</span> <span class="title">start</span><span class="params">(response, postData)</span> {</span>
    <span class="transposed_variable">console.</span>log(<span class="string">"处理请求 '</span><span class="transposed_variable">start'</span> 开启.<span class="string">");

    var body = '</span>&lt;html&gt;<span class="string">'+
        '</span>&lt;head&gt;<span class="string">'+
        '</span>&lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; '</span>+
        <span class="string">'charset=UTF-8"</span> /&gt;<span class="string">'+
        '</span>&lt;/head&gt;<span class="string">'+
        '</span>&lt;body&gt;<span class="string">'+
        '</span>&lt;form action=<span class="string">"/upload"</span> method=<span class="string">"post"</span>&gt;<span class="string">'+
        '</span>&lt;textarea name=<span class="string">"text"</span> rows=<span class="string">"20"</span> cols=<span class="string">"60"</span>&gt;&lt;/textarea&gt;<span class="string">'+
        '</span>&lt;input type=<span class="string">"submit"</span> value=<span class="string">" 提 交 "</span> /&gt;<span class="string">'+
        '</span>&lt;/form&gt;<span class="string">'+
        '</span>&lt;/body&gt;<span class="string">'+
        '</span>&lt;/html&gt;<span class="string">';

    response.writeHead(200, {"</span>Content-Type<span class="string">": "</span>text/html<span class="string">"});
    response.write(body);
    response.end();

}

function upload(response, postData) {
    console.log("</span>处理请求 <span class="string">'upload'</span> 开启.<span class="string">");
    response.writeHead(200, {"</span>Content-Type<span class="string">": "</span>text/plain<span class="string">"});
    response.write("</span>你写的:<span class="string">" + decodeURIComponent(postData));
    response.end();
}

exports.start = start;
exports.upload = upload;</span>
</code></pre><p>4、运行结果： </p>
<p>在 /start 中输入“ 你好 ” ，在 /upload 输出 <code>你写的:text=你好</code></p>
<blockquote>
<p>缺点： 其实一般情况下需要的只是 text 字段；那么，方法是调用 <em>querystring</em> 模块<br>修改 requestHandlers.js </p>
</blockquote>
<pre><code><span class="comment">//原生自带,包括4个方法,看 tips</span>
var querystring = require(<span class="string">'querystring'</span>);

<span class="function"><span class="keyword">function</span> <span class="title">start</span><span class="params">(response, postData)</span> {</span>
    <span class="transposed_variable">console.</span>log(<span class="string">"处理请求 '</span><span class="transposed_variable">start'</span> 开启.<span class="string">");

    var body = '</span>&lt;html&gt;<span class="string">'+
        '</span>&lt;head&gt;<span class="string">'+
        '</span>&lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; '</span>+
        <span class="string">'charset=UTF-8"</span> /&gt;<span class="string">'+
        '</span>&lt;/head&gt;<span class="string">'+
        '</span>&lt;body&gt;<span class="string">'+
        '</span>&lt;form action=<span class="string">"/upload"</span> method=<span class="string">"post"</span>&gt;<span class="string">'+
        '</span>&lt;textarea name=<span class="string">"text"</span> rows=<span class="string">"20"</span> cols=<span class="string">"60"</span>&gt;&lt;/textarea&gt;<span class="string">'+
        '</span>&lt;input type=<span class="string">"submit"</span> value=<span class="string">" 提 交 "</span> /&gt;<span class="string">'+
        '</span>&lt;/form&gt;<span class="string">'+
        '</span>&lt;/body&gt;<span class="string">'+
        '</span>&lt;/html&gt;<span class="string">';

    response.writeHead(200, {"</span>Content-Type<span class="string">": "</span>text/html<span class="string">"});
    response.write(body);
    response.end();

}

function upload(response, postData) {
    console.log("</span>处理请求 <span class="string">'upload'</span> 开启.<span class="string">");
    response.writeHead(200, {"</span>Content-Type<span class="string">": "</span>text/plain<span class="string">"});
    response.write("</span>你写的：&lt;br&gt;<span class="string">" + querystring.parse(decodeURIComponent(postData).text));
    response.end();
}

exports.start = start;
exports.upload = upload;</span>
</code></pre><blockquote>
<p>tips </p>
<p>querystring 类包含4个方法</p>
<p>1、querystring.stringify(obj, [sep], [eq])  将对象转换成字符串<br>2、querystring.parse(str, [sep], [eq], [options]) 将字符串转换成对象<br>3、querystring.escape 参数编码<br>4、querystring.unescape 参数解码</p>
</blockquote>
<h4 id="处理文件上传">处理文件上传</h4><p>效果：允许用户上传图片，并将该图片在浏览器中显示出来。</p>
<p>需要用到外部模块： <em>Felix Geisendörfer</em> 开发的 <strong>node-formidable</strong> 模块</p>
<p>用 NPM 包管理器安装</p>
<pre><code>npm <span class="keyword">install</span> formidable
</code></pre><p>完成后</p>
<p>1、 <strong>requestHandlers.js</strong> 添加图片展示模块，修改上传模块</p>
<pre><code><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>),
    <span class="comment">//可将文件读取到服务器中</span>
    fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);
    <span class="comment">//解析上传文件数据</span>
    formidable = <span class="built_in">require</span>(<span class="string">"formidable"</span>);

<span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">response</span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">"处理请求 'start' 开启."</span>);

    <span class="keyword">var</span> body = <span class="string">'&lt;html&gt;'</span>+
        <span class="string">'&lt;head&gt;'</span>+
        <span class="string">'&lt;meta http-equiv="Content-Type" content="text/html; '</span>+
        <span class="string">'charset=UTF-8" /&gt;'</span>+
        <span class="string">'&lt;/head&gt;'</span>+
        <span class="string">'&lt;body&gt;'</span>+
        <span class="string">'&lt;form action="/upload" enctype="multipart/form-data" '</span>+
        <span class="string">'method="post"&gt;'</span>+
        <span class="string">'&lt;input type="file" name="upload"&gt;'</span>+
        <span class="string">'&lt;input type="submit" value=" 上 传 " /&gt;'</span>+
        <span class="string">'&lt;/form&gt;'</span>+
        <span class="string">'&lt;/body&gt;'</span>+
        <span class="string">'&lt;/html&gt;'</span>;

    response.writeHead(<span class="number">200</span>, {<span class="string">"Content-Type"</span>: <span class="string">"text/html"</span>});
    response.write(body);
    response.end();

}

<span class="function"><span class="keyword">function</span> <span class="title">upload</span>(<span class="params">response, request</span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">"处理请求 'upload' 开启."</span>);

    <span class="keyword">var</span> form = <span class="keyword">new</span> formidable.IncomingForm();
    <span class="built_in">console</span>.log(<span class="string">"加载解析"</span>);
    form.parse(request, <span class="function"><span class="keyword">function</span>(<span class="params">error, fields, files</span>) </span>{
        <span class="built_in">console</span>.log(<span class="string">"解析完成"</span>);

        <span class="keyword">var</span> is = fs.createReadStream(files.upload.path);
        <span class="keyword">var</span> os = fs.createWriteStream(<span class="string">"./tmp/test.png"</span>);
        is.pipe(os);
        is.on(<span class="string">'end'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{
            fs.unlinkSync(files.upload.path);
        });

        <span class="comment">//fs.renameSync(files.upload.path, "./tmp/test.png");</span>
        response.writeHead(<span class="number">200</span>, {<span class="string">"Content-Type"</span>: <span class="string">"text/html"</span>});
        response.write(<span class="string">"收到图片:&lt;br/&gt;"</span>);
        response.write(<span class="string">"&lt;img src='/show' /&gt;"</span>);
        response.end();
    });

}


<span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">response</span>) </span>{
    <span class="built_in">console</span>.log(<span class="string">"处理请求 'show' 开启."</span>);
    fs.readFile(<span class="string">"./tmp/test.png"</span>, <span class="string">"binary"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error, file</span>) </span>{
        <span class="keyword">if</span>(error) {
            response.writeHead(<span class="number">500</span>, {<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>});
            response.write(error + <span class="string">"\n"</span>);
            response.end();
        } <span class="keyword">else</span> {
            response.writeHead(<span class="number">200</span>, {<span class="string">"Content-Type"</span>: <span class="string">"image/png"</span>});
            response.write(file, <span class="string">"binary"</span>);
            response.end();
        }
    });
}

exports.start = start;
exports.upload = upload;
exports.show = show;
</code></pre><p>2、 <strong>index.js</strong> 添加新的请求处理到 路由映射表</p>
<pre><code><span class="built_in">var</span> server = <span class="keyword">require</span>(<span class="string">"./server"</span>),
    router = <span class="keyword">require</span>(<span class="string">"./router"</span>),
    requestHandlers = <span class="keyword">require</span>(<span class="string">"./requestHandlers"</span>);

<span class="built_in">var</span> <span class="keyword">handle</span> = {};
    <span class="keyword">handle</span><span class="preprocessor">[</span><span class="string">"/"</span><span class="preprocessor">]</span><span class="markup"> = requestHandlers.start;
    handle</span><span class="preprocessor">[</span><span class="string">"/start"</span><span class="preprocessor">]</span><span class="markup"> = requestHandlers.start;
    handle</span><span class="preprocessor">[</span><span class="string">"/upload"</span><span class="preprocessor">]</span><span class="markup"> = requestHandlers.upload;
    handle</span><span class="preprocessor">[</span><span class="string">"/show"</span><span class="preprocessor">]</span><span class="markup"> = requestHandlers.show; 

server.start(router.route, handle);</span>
</code></pre><p>3、 <strong>server.js</strong> 移除对postData的处理以及request.setEncoding （这部分node-formidable自身会处理），转而采用将request对象传递给请求路由的方式：</p>
<pre><code><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>),
    url  = <span class="built_in">require</span>(<span class="string">"url"</span>);

<span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params">route, handle</span>) </span>{
    <span class="function"><span class="keyword">function</span> <span class="title">onRequest</span>(<span class="params">request, response</span>) </span>{
        <span class="keyword">var</span> pathname = url.parse(request.url).pathname;
        <span class="built_in">console</span>.log(<span class="string">"请求 "</span>+pathname+<span class="string">" 响应"</span>);
        route(handle, pathname, response, request);
    }

    http.createServer(onRequest).listen(<span class="number">8080</span>);
    <span class="built_in">console</span>.log(<span class="string">"成功的提示：httpd start @8080"</span>);
}

exports.start = start;
</code></pre><p>4、 <strong>router.js</strong> 不需要传递postData了，而要传递request对象</p>
<pre><code><span class="keyword">function</span> route(handle, pathname, <span class="built_in">response</span>, <span class="built_in">request</span>) {
    console.<span class="built_in">log</span>(<span class="string">"route 请求路径："</span> + pathname);
    <span class="keyword">if</span> (typeof handle[pathname] === <span class="comment">'function') {</span>
        handle[pathname](<span class="built_in">response</span>, <span class="built_in">request</span>);
    } <span class="keyword">else</span> {
        console.<span class="built_in">log</span>(<span class="string">"找不到路径 "</span> + pathname);
        <span class="built_in">response</span>.writeHead(<span class="number">404</span>, {<span class="string">"Content-Type"</span>: <span class="string">"text/plain"</span>});
        <span class="built_in">response</span>.write(<span class="string">"404 Not found"</span>);
        <span class="built_in">response</span>.<span class="keyword">end</span>();
    }
}

exports.route = route;
</code></pre><blockquote>
<p>小坑： </p>
</blockquote>
<pre><code><span class="comment">//fs.renameSync(files.upload.path, "./tmp/test.png")</span>
<span class="comment">//报错如下</span>
fs.js:543
  <span class="keyword">return</span> binding.<span class="keyword">rename</span>(pathModule._makeLong(oldPath),
                 ^
<span class="keyword">Error</span>: EXDEV, <span class="keyword">cross</span>-device link not permitted 'C:\User……
……
</code></pre><blockquote>
<p>修改成如下代码即可：</p>
</blockquote>
<pre><code>var <span class="keyword">is</span> = fs.createReadStream(<span class="keyword">files</span>.upload.path);
var os = fs.createWriteStream(<span class="string">"./tmp/test.png"</span>);
<span class="keyword">is</span>.pipe(os);
<span class="keyword">is</span>.<span class="keyword">on</span>(<span class="string">'end'</span>,<span class="function"><span class="keyword">function</span><span class="params">()</span>{</span>
    fs.unlinkSync(<span class="keyword">files</span>.upload.path);
});

//fs.renameSync(<span class="keyword">files</span>.upload.path, <span class="string">"./tmp/test.png"</span>);
</code></pre><p>5、效果演示：(楼主以 .gif为例)</p>
<p><img src="http://images.cnitblog.com/blog/531703/201502/111631185424695.gif" alt="最终效果" title="最终效果"></p>
<blockquote>
<p>注：本文笔记来自于 <a href="https://github.com/manuelkiessling/nodebeginner.org" title="Manuel Kiessling" target="_blank" rel="external">Manuel Kiessling</a>写的 <a href="https://leanpub.com/nodebeginner-chinese" title="Node入门 一本全面的Node.js教程" target="_blank" rel="external">Node入门 一本全面的Node.js教程</a><br>其他： <a href="https://github.com/joyent/node/wiki" title="Node.js community wiki" target="_blank" rel="external">Node.js community wiki</a>——<a href="http://www.nodecloud.org/" title="NodeJS社区" target="_blank" rel="external">NodeJS社区</a></p>
</blockquote>
<h2 id="完">完</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://airuikun.github.io/2015/12/10/2015-12-10-nodeJS 笔记/" data-id="cinfqat97000i58maepsbub31" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/node-js/">node.js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分享/">分享</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/12/10/2015-12-10-node建站/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          node建站
        
      </div>
    </a>
  
  
    <a href="/2015/11/18/2015-11-18-web技术视野/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">记录目前我了解到的一些web技术点</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/frontend/">frontend</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/vue/">vue</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/前端工程/">前端工程</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/我/">我</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/技术/">技术</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/">MySQL</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Phonegap/">Phonegap</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Sublime/">Sublime</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/node-js/">node.js</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/react/">react</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/sass/">sass</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/">vue</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分享/">分享</a><span class="tag-list-count">17</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/前端工程/">前端工程</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/技术视野/">技术视野</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/MySQL/" style="font-size: 15px;">MySQL</a> <a href="/tags/Phonegap/" style="font-size: 10px;">Phonegap</a> <a href="/tags/Sublime/" style="font-size: 10px;">Sublime</a> <a href="/tags/javascript/" style="font-size: 17.5px;">javascript</a> <a href="/tags/node-js/" style="font-size: 17.5px;">node.js</a> <a href="/tags/react/" style="font-size: 12.5px;">react</a> <a href="/tags/sass/" style="font-size: 12.5px;">sass</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/分享/" style="font-size: 20px;">分享</a> <a href="/tags/前端工程/" style="font-size: 12.5px;">前端工程</a> <a href="/tags/技术视野/" style="font-size: 10px;">技术视野</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">十一月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">十月 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">二月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">一月 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">十二月 2014</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/05/">五月 2014</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/02/">二月 2014</a><span class="archive-list-count">4</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/12/22/2015-12-22-关于p标签的问题/">关于p标签的问题</a>
          </li>
        
          <li>
            <a href="/2015/12/21/2015-12-21-react资料汇总(持续)/">react资料汇总(持续)</a>
          </li>
        
          <li>
            <a href="/2015/12/21/2015-12-21-通过NPM快速发布你的NodeJS模块/">通过NPM快速发布你的NodeJS模块（组件包）</a>
          </li>
        
          <li>
            <a href="/2015/12/18/2015-12-18-react初接触/">react初接触</a>
          </li>
        
          <li>
            <a href="/2015/12/12/2015-12-12-Mongodb For Windows/">Mongodb For Windows</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Iray<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>